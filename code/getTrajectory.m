function [key_points,coef,trajectory] = getTrajectory(path)
path_num=length(path);

% record inflection points
key_points=zeros(4,path_num);
point_num=1;
key_points(:,1)=[1;path(1,1:3)'];
for i=2:path_num-1
    if abs(path(i-1,2)-path(i,2)-path(i,2)+path(i+1,2))>0.2 && ~ismember(i-1,key_points)
        point_num=point_num+1;
        key_points(:,point_num)=[i;path(i,1);path(i,2);path(i,3)];
    end
end
key_points(:,point_num+1)=[path_num;path(path_num,1:3)'];
key_points=key_points(:,1:point_num+1);

% calculate coefficient
coef=zeros(12,point_num);
for i=1:point_num
    T=key_points(1,i+1)-key_points(1,i);
    for j=0:2
        a=key_points(j+2,i);
        b=key_points(j+2,i+1);
        C=[0 0 0 1;T^3 T^2 T 1;0 0 1 0;3*T^2 2*T 1 0];
        D=[a;b;0;0];
        coef(j*4+1:j*4+4,i)=C\D;
    end
end
% calculate location of each second
coefX=coef(1:4,:);
coefY=coef(5:8,:);
coefZ=coef(9:12,:);
trajectory=zeros(3,path_num);
part=1;
for i=1:path_num
    if i>key_points(1,part+1)
        part=part+1;
    end
    T=i-key_points(1,part);
    trajectory(1,i)=sum(coefX(:,part).*[T^3;T^2;T;1]);
    trajectory(2,i)=sum(coefY(:,part).*[T^3;T^2;T;1]);
    trajectory(3,i)=sum(coefZ(:,part).*[T^3;T^2;T;1]);
end

% draw trajectory
% figure

% axis([0 100 0 100 0 100])
% mycomet3(trajectory(1,:),trajectory(2,:),trajectory(3,:))

end

% according to path generated by RRT, calculate its trajectory(position for each second)
