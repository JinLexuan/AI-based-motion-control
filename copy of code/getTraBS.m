function [key_points, coef0, trajec1] = getTraBS(path, vel)
path_num = length(path);

% record inflection points
key_points = zeros(4, path_num);
point_num = 1;
key_points(:, 1) = [1; path(1, 1:3)'];
for i = 2 : path_num-1
    if abs(path(i-1, 2)-path(i, 2)-path(i, 2)+path(i+1, 2)) > 0.2 && ~ismember(i-1, key_points)
        point_num = point_num + 1;
        key_points(:, point_num) = [i; path(i,1); path(i,2); path(i,3)];
    end
end
key_points(:, point_num+1) = [path_num; path(path_num, 1: 3)'];
key_points = key_points(:, 1:point_num+1);

% calculate coefficient
coef0 = zeros(12, point_num);
coef1 = zeros(12, point_num);
for i = 1 : point_num
    T = key_points(1, i+1)-key_points(1, i);
    for j = 0 : 2
        a = key_points(j+2, i);
        b = key_points(j+2, i+1);
        C0 = [0 0 0 1;
           T^3 T^2 T 1;
           0 0 1 0;
           3*T^2 2*T 1 0];
        D0 = [a; b; 0; 0];
        coef0(j*4+1:j*4+4, i) = C0\D0;   
        C1 = [0 0 0 1;
           T^3 T^2 T 1;
           0 0 1 0;
           3*T^2 2*T 1 0];
        D1 = [a; b; min((i-1)*vel, vel); vel];
        coef1(j*4+1:j*4+4, i) = C1\D1;   
    end
end
% calculate location of each second
coefX0 = coef0(1:4, :);
coefY0 = coef0(5:8, :);
coefZ0 = coef0(9:12, :);
trajec0 = zeros(3, path_num);
coefX1 = coef1(1:4, :);
coefY1 = coef1(5:8, :);
coefZ1 = coef1(9:12, :);
trajec1 = zeros(3, path_num);
part = 1;
flag = 0;
for i = 1 : path_num
    if i>key_points(1, part+1)
        while flag > 0
            start = key_points(1, part);
            final = key_points(1, part+1);
            trajec1(:, start : final) = (trajec1(:, start : final) + trajec0(:, start : final)) / 2;
            flag = flag - 1;
        end
        part = part + 1; 
    end
    
    T = i - key_points(1, part);
    trajec0(1, i)=sum(coefX0(:, part) .* [T^3; T^2; T; 1]);
    trajec0(2, i)=sum(coefY0(:, part) .* [T^3; T^2; T; 1]);
    trajec0(3, i)=sum(coefZ0(:, part) .* [T^3; T^2; T; 1]);
    trajec1(1, i)=sum(coefX1(:, part) .* [T^3; T^2; T; 1]);
    trajec1(2, i)=sum(coefY1(:, part) .* [T^3; T^2; T; 1]);
    trajec1(3, i)=sum(coefZ1(:, part) .* [T^3; T^2; T; 1]);
    traX = trajec1(1, i); traY = trajec1(2, i); traZ = trajec1(3, i);
    if traX < 2 || traX > 98 || traY < 2 || traY > 98 || traZ < 2 || traZ > 98
        flag = flag + 1;
    end
end

% draw trajectory
% figure

% axis([0 100 0 100 0 100])
% mycomet3(trajectory(1,:),trajectory(2,:),trajectory(3,:))

end

% according to path generated by RRT, calculate its trajectory(position for each second)
